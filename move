void move(char c) { // 방향키 이동
	switch (c) {
	case 'h': // 왼쪽
		if (map_f[p_x - 1][p_y][0] != '#') { // 움직이는 방향에 벽이 없을경우만 코드 실행
			if (map_f[p_x - 1][p_y][0] == '$') { // 움직이는 방향에 박스가 있는지 없는지 상황 판단
				if (map_f[p_x - 2][p_y][0] == 32 || map_f[p_x - 2][p_y][0] == 'O') {
					undo_s(); // undo를 위한 파일 저장 
					map_f[p_x - 2][p_y][0] = '$'; // 맵 파일 배열에서 박스 위치 변경
					map_f[p_x - 1][p_y][0] = '@'; // 플레이어 위치 변경
					map_f[p_x][p_y][0] = 32; // ASCII 코드 32 = ' ', 플레이어 위치에 공백 저장
					p_x--; // 좌표를 왼쪽으로 한칸 이동
					if (!clr()) { // 클리어시 출력은 하지 않음
						mv_cur(p_x, p_y + 3);
						printf("$@ "); // 박스,플레이어 순서로 출력하고 플레이어가 원래 있던 위치에 공백 출력
					}
					undo_k(c); // 키보드 백업
					k_mv++; // 키보드 이동횟수 증가
				}
			}
			else { // 박스가 없을 경우 
				undo_s();
				map_f[p_x - 1][p_y][0] = '@'; // 맵 파일 배열에서 플레이어 위치 변경
				map_f[p_x][p_y][0] = 32; // 플레이어 있던 위치에 공백 저장
				p_x--; // 좌표를 왼쪽으로 한칸 이동
				mv_cur(p_x + 1, p_y + 3); // 커서 이동
				printf("@ "); // 플레이어 출력하고, 플레이어 원래 있던 위치에 공백 출력
				undo_k(c); // 키보드 백업
				k_mv++; // 키보드 이동횟수 증가
			}
		}
		break;
	case 'j': // 아래
		if (map_f[p_x][p_y + 1][0] != '#') { // 움직이는 방향에 벽이 없을경우만 코드 실행
			if (map_f[p_x][p_y + 1][0] == '$') { // 움직이는 방향에 박스가 있는지 없는지 상황 판단
				if (map_f[p_x][p_y + 2][0] == 32 || map_f[p_x][p_y + 2][0] == 'O') {
					undo_s(); // undo를 위한 파일 저장
					map_f[p_x][p_y + 2][0] = '$'; // 맵 파일 배열에서 위치 변경
					map_f[p_x][p_y + 1][0] = '@'; // 플레이어 위치 변경
					map_f[p_x][p_y][0] = 32; // ASCII 코드 32 = ' ', 플레이어 위치에 공백 저장
					p_y++; // 좌표를 아래쪽으로 한칸 이동
					if (!clr()) { // 클리어시 출력은 하지 않음
						mv_cur(p_x + 1, p_y + 2);
						printf(" ");
						mv_cur(p_x + 1, p_y + 3);
						printf("@");
						mv_cur(p_x + 1, p_y + 4);
						printf("$");  // 움직인 플레이어 위치를 중심으로 위에 공백, 아래에 박스를 출력
					}
					undo_k(c); // 키보드 백업
					k_mv++; // 키보드 이동횟수 증가
				}
			}
			else { // 박스가 없을 경우
				undo_s(); // undo를 위한 파일 저장
				map_f[p_x][p_y + 1][0] = '@'; // 맵 파일 배열에서 플레이어 위치 변경
				map_f[p_x][p_y][0] = 32; // 플레이어 위치에 공백 저장
				p_y++; // 좌표를 아래쪽으로 한칸 이동
				mv_cur(p_x + 1, p_y + 2);
				printf(" ");
				mv_cur(p_x + 1, p_y + 3);
				printf("@"); // 움직인 플레이어 위치를 중심으로 위에 공백을 출력
				undo_k(c); // 키보드 백업
				k_mv++; // 키보드 이동횟수 증가
			}
		}
		break;
	case 'k': // 위쪽
		if (map_f[p_x][p_y - 1][0] != '#') { // 움직이는 방향에 벽이 없을경우만 코드 실행
			if (map_f[p_x][p_y - 1][0] == '$') { // 움직이는 방향에 박스가 있는지 없는지 상황 판단
				if (map_f[p_x][p_y - 2][0] == 32 || map_f[p_x][p_y - 2][0] == 'O') {
					undo_s();// undo를 위한 파일 저장 
					map_f[p_x][p_y - 2][0] = '$'; // 맵 파일 배열에서 박스 위치 변경
					map_f[p_x][p_y - 1][0] = '@'; // 플레이어 위치 변경
					map_f[p_x][p_y][0] = 32; // ASCII 코드 32 = ' '
					p_y--;
					if (!clr()) {
						mv_cur(p_x + 1, p_y + 2);
						printf("$");
						mv_cur(p_x + 1, p_y + 3);
						printf("@");
						mv_cur(p_x + 1, p_y + 4);
						printf(" "); // 움직인 플레이어 위치를 중심으로 위에 박스, 아래 공백 출력
					}
					undo_k(c);// 키보드 백업
					k_mv++;// 키보드 이동횟수 증가
				}
			}
			else {
				undo_s();
				map_f[p_x][p_y - 1][0] = '@';// 맵 파일 배열에서 플레이어 위치 변경
				map_f[p_x][p_y][0] = 32; // 플레이어 있던 위치에 공백 저장
				p_y--;
				mv_cur(p_x + 1, p_y + 3);
				printf("@");
				mv_cur(p_x + 1, p_y + 4);
				printf(" ");// 플레이어가 있던자리에 공백을 출력하고 위에는 플레이어를 출력
				undo_k(c); // 키보드 백업
				k_mv++;// 키보드 이동횟수 증가
			}
		}
		break;
	case 'l': // 오른쪽
		if (map_f[p_x + 1][p_y][0] != '#') { // 움직이는 방향에 벽이 없을경우만 코드 실행
			if (map_f[p_x + 1][p_y][0] == '$') { // 움직이는 방향에 박스가 있는지 없는지 상황 판단
				if (map_f[p_x + 2][p_y][0] == 32 || map_f[p_x + 2][p_y][0] == 'O') {
					undo_s(); // undo를 위한 파일 저장 
					map_f[p_x + 2][p_y][0] = '$'; // 맵 파일 배열에서 박스 위치 변경
					map_f[p_x + 1][p_y][0] = '@'; // 플레이어 위치 변경
					map_f[p_x][p_y][0] = 32; // ASCII 코드 32 = ' '
					p_x++;
					if (!clr()) {
						mv_cur(p_x, p_y + 3);
						printf(" @$");// 공백, 플레이어, 박스 순으로 출력
					}
					undo_k(c); // 키보드 백업
					k_mv++;// 키보드 이동횟수 증가
				}
			}
			else {
				undo_s();
				map_f[p_x + 1][p_y][0] = '@';// 맵 파일 배열에서 플레이어 위치 변경
				map_f[p_x][p_y][0] = 32; // 플레이어 있던 위치에 공백 저장
				p_x++;
				mv_cur(p_x, p_y + 3);
				printf(" @");// 공백, 플레이어 순으로 출력
				undo_k(c); // 키보드 백업
				k_mv++;// 키보드 이동횟수 증가
			}
		}
		break;
	}
	chk_p();
	com_cur();
}
